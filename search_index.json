[["index.html", "SingleCellMQC 1 About 1.1 Introduction 1.2 Installation 1.3 Bugs", " SingleCellMQC Daihan Ji#, Mei Han#, Shuting Lu, Jiaying Zeng, Wen Zhong* 2025-05-08 1 About 1.1 Introduction The SingleCellMQC pipeline is developed in R and accepts input files from scRNA-seq, surface protein seqencing, scTCR-seq, and scBCR-seq to perform QC analysis. The pipeline utilizes the Seurat and BPCells objects to store and analyze large data. The pipeline consists of four major QC modules: (i) sample QC, (ii) cell QC, (iii) feature QC, and (iv) batch QC. Each module encompasses a range of functions, including QC metrics assessment, outlier sample detection, abnormal cell identification, background noise detection, batch effect evaluation, etc. Data visualization for each module encompasses a variety of elements, including static graphs, interactive graphs, and interactive tables. In particular, each module supports the generation of HTML reports for multi-omics quality control (QC) based on R Markdown, which contains QC results and potential warnings. 1.2 Installation Before installation, we recommend installing these dependencies first: Seurat (single-cell analysis toolkit) BPCells (memory-efficient single-cell data processing) You can install the development version of SingleCellMQC from GitHub with: if (!requireNamespace(&quot;devtools&quot;, quietly = TRUE)) { install.packages(&quot;devtools&quot;) } devtools::install_github(&#39;WenZhong-Lab/SingleCellMQC&#39;) library(SingleCellMQC) 1.3 Bugs If you encounter any issues or have questions, please open an issue on GitHub. We’ll be happy to assist! "],["load-and-add-data.html", "2 Load and add data 2.1 Loading data of scRNA-seq or CITE-seq 2.2 Loading data of scV(D)J-seq 2.3 Loading data of multi-omics (scRNA-seq/CITE-seq + scV(D)J-seq) 2.4 Loading and adding 10X metrics 2.5 Adding information of samples", " 2 Load and add data Compiled: 2025-05-08 Written by Jiaying Zeng and Daihan Ji library(SingleCellMQC) SingleCellMQC provides number of functions to simplify the process of loading single-cell multi-omics data as well as clinical information. Multi-omics includes scRNA-seq, CITE-seq (RNA+ADT), and scTCR/BCR-seq. Generally, GEX data will be automatically constructed into a Seurat object after reading. If you want to reduce memory usage, we encourage users to use BPCells package read and save data. We support BPCells read operations in our read functions. 2.1 Loading data of scRNA-seq or CITE-seq 2.1.1 Data import Without BPCells Upon standard Cell Ranger pipeline, you will have a lot of output files. The input directory should contained barcodes.tsv.gz, features.tsv.gz and matrix.mtx.gz. sample_filtered_feature_bc_matrix/ ├── barcodes.tsv.gz ├── features.tsv.gz └── matrix.mtx.gz # A vector of outputs of the Cell Ranger pipeline from 10X dir_GEX &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/sample_filtered_feature_bc_matrix/&quot; ) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) pbmc_GEX &lt;- Read10XData(dir_GEX = dir_GEX, sample = sample_name) pbmc_GEX ## An object of class Seurat ## 36738 features across 28498 samples within 2 assays ## Active assay: RNA (36601 features, 0 variable features) ## 1 layer present: counts ## 1 other assay present: ADT # Show the size of the subject print(object.size(pbmc_GEX), units = &quot;auto&quot;) ## 575.9 Mb If your cell×gene expression matrix data is stored in HDF5 file format, use Read10XH5Data instead. The input file sample_filtered_feature_bc_matrix.h5 should be contained. # A vector of outputs of the Cell Ranger pipeline from 10X dir_GEX &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/sample_filtered_feature_bc_matrix.h5&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/sample_filtered_feature_bc_matrix.h5&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/sample_filtered_feature_bc_matrix.h5&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/sample_filtered_feature_bc_matrix.h5&quot; ) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) pbmc_GEX &lt;- Read10XH5Data(dir_GEX = dir_GEX, sample = sample_name) 2.1.2 Data import With BPCells BPCells is a powerful tool designed for efficient handling of large-scale single-cell datasets. In this section, we demonstrate how to import single-cell data using BPCells, leveraging its optimized storage and memory management capabilities. Whether you’re working with 10x Genomics, HDF5, or other formats, BPCells provides a seamless and scalable solution for data import, enabling more memory-efficient workflows. To enable BPCells-based data reading, simply set saveBPCells=TRUE and specify the dir_BPCells path for saving the processed data. Read10XData() and Read10XH5Data() functions support BPCells-based data reading. # A vector of outputs of the Cell Ranger pipeline from 10X dir_GEX &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/sample_filtered_feature_bc_matrix/&quot; ) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) pbmc &lt;- Read10XData(dir_GEX = dir_GEX, sample = sample_name, saveBPCells = T, dir_BPCells = &quot;./BPCellData&quot;) pbmc ## An object of class Seurat ## 36738 features across 28498 samples within 2 assays ## Active assay: RNA (36601 features, 0 variable features) ## 1 layer present: counts ## 1 other assay present: ADT # Show the size of the subject print(object.size(pbmc), units = &quot;auto&quot;) ## 27.7 Mb 2.2 Loading data of scV(D)J-seq Upon standard Cell Ranger pipeline, you will have a lot of output files. For scV(D)J-seq, the input file filtered_contig_annotations.csv should be contained. vdj_out/\\ ├── filtered_contig_annotations.csv \\&lt;-- **This contains the count data we want!**\\ ├── clonotypes.csv\\ └── ... # A vector of outputs of the Cell Ranger pipeline from 10X dir_TCR &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/vdj_t/filtered_contig_annotations.csv&quot; ) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) pbmc_tcr &lt;- Read10XData(dir_TCR = dir_TCR, sample = sample_name) str(pbmc_tcr, list.len = 4) ## List of 4 ## $ TP1 :&#39;data.frame&#39;: 5360 obs. of 32 variables: ## ..$ barcode : chr [1:5360] &quot;AAACCTGAGAATGTTG-1&quot; &quot;AAACCTGAGAATGTTG-1&quot; &quot;AAACCTGCAAGCGATG-1&quot; &quot;AAACCTGCAAGCGATG-1&quot; ... ## ..$ is_cell : logi [1:5360] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ contig_id : chr [1:5360] &quot;AAACCTGAGAATGTTG-1_contig_1&quot; &quot;AAACCTGAGAATGTTG-1_contig_2&quot; &quot;AAACCTGCAAGCGATG-1_contig_1&quot; &quot;AAACCTGCAAGCGATG-1_contig_2&quot; ... ## ..$ high_confidence : logi [1:5360] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. [list output truncated] ## $ TP2 :&#39;data.frame&#39;: 4271 obs. of 32 variables: ## ..$ barcode : chr [1:4271] &quot;AAACCTGAGTGAAGTT-1&quot; &quot;AAACCTGGTCACACGC-1&quot; &quot;AAACCTGGTCACACGC-1&quot; &quot;AAACCTGTCTGCAAGT-1&quot; ... ## ..$ is_cell : logi [1:4271] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ contig_id : chr [1:4271] &quot;AAACCTGAGTGAAGTT-1_contig_1&quot; &quot;AAACCTGGTCACACGC-1_contig_1&quot; &quot;AAACCTGGTCACACGC-1_contig_2&quot; &quot;AAACCTGTCTGCAAGT-1_contig_1&quot; ... ## ..$ high_confidence : logi [1:4271] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. [list output truncated] ## $ TP3 :&#39;data.frame&#39;: 695 obs. of 32 variables: ## ..$ barcode : chr [1:695] &quot;AAACCTGTCGTTGCCT-1&quot; &quot;AAAGATGCATGGATGG-1&quot; &quot;AAAGATGCATGGATGG-1&quot; &quot;AACACGTAGAGTAAGG-1&quot; ... ## ..$ is_cell : logi [1:695] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ contig_id : chr [1:695] &quot;AAACCTGTCGTTGCCT-1_contig_1&quot; &quot;AAAGATGCATGGATGG-1_contig_1&quot; &quot;AAAGATGCATGGATGG-1_contig_2&quot; &quot;AACACGTAGAGTAAGG-1_contig_1&quot; ... ## ..$ high_confidence : logi [1:695] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. [list output truncated] ## $ TP3-rep:&#39;data.frame&#39;: 2883 obs. of 32 variables: ## ..$ barcode : chr [1:2883] &quot;AAACCTGAGTGGGATC-1&quot; &quot;AAACCTGCACTTAACG-1&quot; &quot;AAACCTGCACTTAACG-1&quot; &quot;AAACCTGGTGAAGGCT-1&quot; ... ## ..$ is_cell : logi [1:2883] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ contig_id : chr [1:2883] &quot;AAACCTGAGTGGGATC-1_contig_1&quot; &quot;AAACCTGCACTTAACG-1_contig_1&quot; &quot;AAACCTGCACTTAACG-1_contig_2&quot; &quot;AAACCTGGTGAAGGCT-1_contig_1&quot; ... ## ..$ high_confidence : logi [1:2883] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. [list output truncated] ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;list&quot; &quot;VDJ&quot; # A vector of outputs of the Cell Ranger pipeline from 10X dir_BCR &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/vdj_b/filtered_contig_annotations.csv&quot; ) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) pbmc_bcr &lt;- Read10XData(dir_BCR = dir_BCR, sample = sample_name) str(pbmc_bcr, list.len = 4) ## List of 4 ## $ TP1 :&#39;data.frame&#39;: 1110 obs. of 32 variables: ## ..$ barcode : chr [1:1110] &quot;AAACCTGGTAGCCTAT-1&quot; &quot;AAACCTGGTAGCCTAT-1&quot; &quot;AAACCTGGTTCGAATC-1&quot; &quot;AAACCTGGTTCGAATC-1&quot; ... ## ..$ is_cell : logi [1:1110] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ contig_id : chr [1:1110] &quot;AAACCTGGTAGCCTAT-1_contig_1&quot; &quot;AAACCTGGTAGCCTAT-1_contig_2&quot; &quot;AAACCTGGTTCGAATC-1_contig_1&quot; &quot;AAACCTGGTTCGAATC-1_contig_2&quot; ... ## ..$ high_confidence : logi [1:1110] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. [list output truncated] ## $ TP2 :&#39;data.frame&#39;: 2061 obs. of 32 variables: ## ..$ barcode : chr [1:2061] &quot;AAACCTGCATCGGGTC-1&quot; &quot;AAACCTGCATCGGGTC-1&quot; &quot;AAACCTGCATCGGGTC-1&quot; &quot;AAACCTGGTAGAGTGC-1&quot; ... ## ..$ is_cell : logi [1:2061] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ contig_id : chr [1:2061] &quot;AAACCTGCATCGGGTC-1_contig_1&quot; &quot;AAACCTGCATCGGGTC-1_contig_2&quot; &quot;AAACCTGCATCGGGTC-1_contig_3&quot; &quot;AAACCTGGTAGAGTGC-1_contig_1&quot; ... ## ..$ high_confidence : logi [1:2061] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. [list output truncated] ## $ TP3 :&#39;data.frame&#39;: 1538 obs. of 32 variables: ## ..$ barcode : chr [1:1538] &quot;AAACGGGCAGCAGTTT-1&quot; &quot;AAACGGGCAGCAGTTT-1&quot; &quot;AAACGGGGTTCAGTAC-1&quot; &quot;AAACGGGGTTCAGTAC-1&quot; ... ## ..$ is_cell : logi [1:1538] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ contig_id : chr [1:1538] &quot;AAACGGGCAGCAGTTT-1_contig_1&quot; &quot;AAACGGGCAGCAGTTT-1_contig_2&quot; &quot;AAACGGGGTTCAGTAC-1_contig_1&quot; &quot;AAACGGGGTTCAGTAC-1_contig_2&quot; ... ## ..$ high_confidence : logi [1:1538] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. [list output truncated] ## $ TP3-rep:&#39;data.frame&#39;: 1371 obs. of 32 variables: ## ..$ barcode : chr [1:1371] &quot;AAACCTGGTTGTTTGG-1&quot; &quot;AAACCTGGTTGTTTGG-1&quot; &quot;AAACGGGCAAGTACCT-1&quot; &quot;AAACGGGCAAGTACCT-1&quot; ... ## ..$ is_cell : logi [1:1371] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ contig_id : chr [1:1371] &quot;AAACCTGGTTGTTTGG-1_contig_1&quot; &quot;AAACCTGGTTGTTTGG-1_contig_2&quot; &quot;AAACGGGCAAGTACCT-1_contig_1&quot; &quot;AAACGGGCAAGTACCT-1_contig_2&quot; ... ## ..$ high_confidence : logi [1:1371] TRUE TRUE TRUE TRUE TRUE TRUE ... ## .. [list output truncated] ## - attr(*, &quot;class&quot;)= chr [1:2] &quot;list&quot; &quot;VDJ&quot; 2.3 Loading data of multi-omics (scRNA-seq/CITE-seq + scV(D)J-seq) Upon standard Cell Ranger pipeline, you will have a lot of output files. The input directory (scRNA-seq or CITE-seq) barcodes.tsv.gz, features.tsv.gz and matrix.mtx.gz should contained. If your cell×gene expression matrix data is stored in HDF5 file format, use Read10XH5Data instead. The input file (scV(D)J-seq) filtered_contig_annotations.csv also should be contained. sample_filtered_feature_bc_matrix/ ├── barcodes.tsv.gz ├── features.tsv.gz └── matrix.mtx.gz vdj_out/ ├── filtered_contig_annotations.csv &lt;– This contains the count data we want! ├── clonotypes.csv └── … # A vector of outputs of the Cell Ranger pipeline from 10X dir_GEX &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/sample_filtered_feature_bc_matrix/&quot; ) dir_TCR &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/vdj_t/filtered_contig_annotations.csv&quot; ) dir_BCR &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/vdj_b/filtered_contig_annotations.csv&quot; ) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) pbmc &lt;- Read10XData(dir_GEX = dir_GEX, dir_TCR = dir_TCR, dir_BCR = dir_BCR, sample = sample_name) pbmc # Show the size of the subject print(object.size(pbmc), units = &quot;auto&quot;) What if you want to implement more memory-efficient workflows by BPCells-based data reading? Note, that this is only possible for Seurat V5, you can use the following: # A vector of outputs of the Cell Ranger pipeline from 10X dir_GEX &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/sample_filtered_feature_bc_matrix/&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/sample_filtered_feature_bc_matrix/&quot; ) dir_TCR &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/vdj_t/filtered_contig_annotations.csv&quot; ) dir_BCR &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/vdj_b/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/vdj_b/filtered_contig_annotations.csv&quot; ) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) pbmc &lt;- Read10xData(dir_GEX = dir_GEX, dir_TCR = dir_TCR, dir_BCR = dir_BCR, sample = sample_name, saveBPCells = T) pbmc # Show the size of the subject print(object.size(pbmc), units = &quot;auto&quot;) 2.4 Loading and adding 10X metrics Upon standard Cell Ranger pipeline, you will obtain a summary of key sequencing and analysis metrics for single-cell experiments. To integrate it into your Seurat object, follow the steps below. (Ensure that it has been turned into a Seurat object using CalculateMetrics, for example) The input file metrics_summary.csv should be contained. seq_list &lt;- c(&quot;/data/SingleCellMQC/CellRanger/TP1/metrics_summary.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/metrics_summary.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/metrics_summary.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/metrics_summary.csv&quot;) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) names(seq_list) &lt;- sample_name seq_metrics &lt;- Read10XMetrics(file_path = seq_list) pbmc &lt;- Add10XMetrics(pbmc, seq_metrics) 2.5 Adding information of samples You can add other information of your samples using AddSampleMeta. The information would be store into pbmc@metadata. sample_information &lt;- data.frame( Sample = c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;), Batch_EXP = c(&quot;EXP-1&quot;, &quot;EXP-2&quot;, &quot;EXP-3&quot;, &quot;EXP-4&quot;), Batch_TotalSeq_C_Antibodies = c(&quot;AB-1&quot;, &quot;AB-1&quot;, &quot;AB-1&quot;, &quot;AB-2&quot;), Sex = c(&quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;, &quot;Male&quot;), Time_point = c(&quot;TP-1&quot;, &quot;TP-2&quot;, &quot;TP-3&quot;, &quot;TP-3&quot;) ) pbmc &lt;- AddSampleMeta(pbmc, merge_by_seurat=&quot;orig.ident&quot;, SampleMeta= sample_information, merge_by_meta = &quot;Sample&quot;) "],["sample-qc.html", "3 Sample QC 3.1 Sample quality assessment 3.2 PCT outlier sample detection 3.3 Sample identity verification", " 3 Sample QC Compiled: 2025-05-08 Written by Shuting Lu and Daihan Ji library(SingleCellMQC) #Load a pre-existing Seurat object or process raw data using SingleCellMQC. pbmc &lt;- readRDS(&quot;/data/pbmc.rds&quot;) The main tasks of sample-level QC include: Sample quality assessment- Detecting technical artifacts that may caused by library construction, insufficient sequencing depth, amplification biases, and contaminations; Outlier sample detection- Identifying outlier samples with low cell counts, poor RNA quality, or unexpected cell type compositions, et.al; Sample identity verification- Recognizing incorrect sample labeling that might be caused by errors in sample handling. Calculating sample metrics before QC SingleCellMQC simplifies the process of calculating multi-omics metrics for sample quality control, enabling researchers to efficiently assess data quality before proceeding with downstream analysis. It offers a comprehensive suite of QC metrics designed to evaluate single-cell data quality at the sample level, covering diverse modalities such as RNA sequencing, surface protein profiling (ADT), and TCR/BCR sequencing. # Calculate the information of sample metrics. pbmc &lt;- CalculateMetrics(pbmc) 3.1 Sample quality assessment The main include: 10X metrics assessment: Derived from the Cell Ranger output (if available). Basic metrics assessment: Calculated by SingleCellMQC after preprocessing with tools such as Cell Ranger, dnbc4tools, and others. V(D)J overview: Detailed metrics and analysis of V(D)J data (if available). 3.1.1 10X metrics assessment This section provides a summary of the 10X metrics alerts. The alerts are generated based on the 10X Genomics CellRanger requirements. The alerts are divided into two categories: errors and warnings. Errors indicate that the sample may have serious problems, while warnings indicate that the sample may have potential problems. Loading 10X metrics seq_list &lt;- c(&quot;/data/SingleCellMQC/CellRanger/TP1/metrics_summary.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/metrics_summary.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/metrics_summary.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/metrics_summary.csv&quot;) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) names(seq_list) &lt;- sample_name seq_metrics &lt;- Read10XMetrics(file_path = seq_list) pbmc &lt;- Add10XMetrics(pbmc, seq_metrics) ##show 10x metrics ShowSampleMetricsName(pbmc, type=&quot;Metrics_10x&quot;) Generate Cell Ranger alerts for QC metrics # Using a Seurat object, A data frame if return.type is &quot;table&quot;. An interactive HTML table if return.type is &quot;interactive_table&quot;. alerts &lt;- CellRangerAlerts(pbmc, return.type = &quot;interactive_table&quot;) alerts Group by None Alerts type Metrics Sample Download as CSV 10X Metrics Alerts 3.1.2 Basic metrics assessment 3.1.2.1 Visualisation of sample metrics Visualising metrics using barcharts By selecting the metrics of interest in this module, differences between individual samples can be visualised.PlotSampleMetrics(). “type” can be used to indicate whether the visualisation is a “count” or a “summary”. “metrics” can be used to specify the metrics of interest, eg “nCell” and “nGene_RNA”. # Show sample metrics ShowSampleMetricsName(pbmc, type = &quot;count&quot;) ## [1] &quot;nCell&quot; &quot;nGene_RNA&quot; &quot;nPro_ADT&quot; &quot;nChain_TCR&quot; &quot;nCell_TCR&quot; &quot;TCR%&quot; &quot;nChain_TRA&quot; &quot;nCell_TRA&quot; &quot;TRA%&quot; ## [10] &quot;nChain_TRB&quot; &quot;nCell_TRB&quot; &quot;TRB%&quot; &quot;nChain_BCR&quot; &quot;nCell_BCR&quot; &quot;BCR%&quot; &quot;nChain_IGH&quot; &quot;nCell_IGH&quot; &quot;IGH%&quot; ## [19] &quot;nChain_IGK&quot; &quot;nCell_IGK&quot; &quot;IGK%&quot; &quot;nChain_IGL&quot; &quot;nCell_IGL&quot; &quot;IGL%&quot; &quot;IGH + IGK&quot; &quot;IGH + IGL&quot; &quot;TRA + TRB&quot; ## [28] &quot;ambiguous_TB&quot; &quot;multichain_B&quot; &quot;multichain_T&quot; &quot;single IGH&quot; &quot;single IGK&quot; &quot;single IGL&quot; &quot;single TRA&quot; &quot;single TRB&quot; &quot;IGH + IGK%&quot; ## [37] &quot;IGH + IGL%&quot; &quot;TRA + TRB%&quot; &quot;ambiguous_TB%&quot; &quot;multichain_B%&quot; &quot;multichain_T%&quot; &quot;single IGH%&quot; &quot;single IGK%&quot; &quot;single IGL%&quot; &quot;single TRA%&quot; ## [46] &quot;single TRB%&quot; # Visualisation of the count number of metrics. PlotSampleMetrics(pbmc, type=&quot;count&quot;, metrics=c(&quot;nCell&quot;, &quot;nGene_RNA&quot;, &quot;nPro_ADT&quot;, &quot;TCR%&quot;, &quot;BCR%&quot;), return.type = &quot;plot&quot; ) ## &gt; - 4 samples contain 28498 cells, 7075 cells contain TCR information, 3008 cells contain BCR information. ## &gt; - 0 samples less than 1000 cells : `` ## &gt; - 0 samples more than 20000 cells : `` # Show sample metrics ShowSampleMetricsName(pbmc, type = &quot;summary&quot;) ## [1] &quot;nCount_RNA&quot; &quot;nFeature_RNA&quot; &quot;nCount_ADT&quot; &quot;nFeature_ADT&quot; &quot;percent.mt&quot; &quot;percent.rb&quot; ## [7] &quot;percent.hb&quot; &quot;percent.dissociation&quot; &quot;per_feature_count_RNA&quot; &quot;per_feature_count_ADT&quot; # Visualisation of summary of cell metrics. PlotSampleMetrics(pbmc, type=&quot;summary&quot;, metrics=c(&quot;percent.mt&quot;), return.type = &quot;plot&quot; ) Visualising metrics using interactive table When the information from the interactive table is displayed, the file can be saved in CSV format by clicking on the “Download as CSV” button in the top left hand corner. This is also possible with the following interactive tables. # Show interactive table. out&lt;-PlotSampleMetrics(pbmc, type=&quot;summary&quot;, metrics=c(&quot;percent.mt&quot;), return.type = &quot;interactive_table&quot; ) #Count information in the interaction table out$base Download as CSV Metrics #Average information in the interaction table out$statistics Download as CSV Metrics summary table Visualising metrics using violin diagram Violin plots can also be used to show metrics information between samples, only for cell metrics. ## Show cell metrics ShowCellMetricsName(pbmc) ## [1] &quot;receptor_type&quot; &quot;receptor_subtype&quot; &quot;chain_pair&quot; &quot;nChain_TRA&quot; &quot;nChain_TRB&quot; &quot;nChain_BCR&quot; ## [7] &quot;nChain_IGH&quot; &quot;nChain_IGK&quot; &quot;nChain_IGL&quot; &quot;orig.ident&quot; &quot;nCount_RNA&quot; &quot;nFeature_RNA&quot; ## [13] &quot;nCount_ADT&quot; &quot;nFeature_ADT&quot; &quot;percent.mt&quot; &quot;percent.rb&quot; &quot;percent.hb&quot; &quot;percent.dissociation&quot; ## [19] &quot;per_feature_count_RNA&quot; &quot;per_feature_count_ADT&quot; &quot;percent.isotype&quot; # Select mitochondrial information to display by specifying ‘metrics’. PlotCellMetrics(pbmc, group.by = &quot;orig.ident&quot;, metrics = c(&quot;percent.mt&quot;)) # Multiple metrics can also be selected for drawing. out &lt;- PlotCellMetrics(pbmc, group.by = &quot;orig.ident&quot;, metrics = c(&quot;percent.mt&quot;, &quot;nCount_RNA&quot;)) names(out) ## [1] &quot;percent.mt&quot; &quot;nCount_RNA&quot; 3.1.2.2 Using MAD to flag sample metrics warnings To identify potential warning samples, SingleCellMQC employs the FindSampleMetricsWarning function, which applies Median Absolute Deviation (MAD) to flag samples deviating from general distributions of key QC metrics. By default, the metrics analyzed include: nCount_RNA, nFeature_RNA, nCount_ADT, nFeature_ADT, percent.mt, and percent.isotype. out table out &lt;- FindSampleMetricsWarning(pbmc, sample.by = &quot;orig.ident&quot;) ## nCount_RNA warning samples: TP3 ## nFeature_RNA warning samples: TP3 ## nCount_ADT warning samples: TP2 ## percent.mt warning samples: TP3 # View the format of the table str(out) ## List of 2 ## $ table:&#39;data.frame&#39;: 24 obs. of 7 variables: ## ..$ sample : chr [1:24] &quot;TP1&quot; &quot;TP2&quot; &quot;TP3&quot; &quot;TP3-rep&quot; ... ## ..$ metrics_name : chr [1:24] &quot;nCount_RNA&quot; &quot;nCount_RNA&quot; &quot;nCount_RNA&quot; &quot;nCount_RNA&quot; ... ## ..$ metrics_value: num [1:24] 3990 3627 2079 4042 1680 ... ## ..$ cutoff : num [1:24] 2989 2989 2989 2989 1328 ... ## ..$ type : chr [1:24] &quot;lower&quot; &quot;lower&quot; &quot;lower&quot; &quot;lower&quot; ... ## ..$ log : logi [1:24] TRUE TRUE TRUE TRUE TRUE TRUE ... ## ..$ isFlagged : &#39;outlier.filter&#39; logi [1:24] FALSE FALSE TRUE FALSE FALSE FALSE ... ## .. ..- attr(*, &quot;thresholds&quot;)= Named num [1:2] 2989 Inf ## .. .. ..- attr(*, &quot;names&quot;)= chr [1:2] &quot;lower&quot; &quot;higher&quot; ## $ list :List of 6 ## ..$ nCount_RNA : chr &quot;TP3&quot; ## ..$ nFeature_RNA : chr &quot;TP3&quot; ## ..$ nCount_ADT : chr &quot;TP2&quot; ## ..$ nFeature_ADT : chr(0) ## ..$ percent.mt : chr &quot;TP3&quot; ## ..$ percent.isotype: chr(0) interactive table out &lt;- FindSampleMetricsWarning(pbmc, sample.by = &quot;orig.ident&quot;, return.type = &quot;interactive_table&quot;) ## nCount_RNA warning samples: TP3 ## nFeature_RNA warning samples: TP3 ## nCount_ADT warning samples: TP2 ## percent.mt warning samples: TP3 out Group by None Metrics Sample Download as CSV Metrics warning results (MAD Statistics) plot out &lt;- FindSampleMetricsWarning(pbmc, sample.by = &quot;orig.ident&quot;, return.type = &quot;plot&quot;) ## nCount_RNA warning samples: TP3 ## nFeature_RNA warning samples: TP3 ## nCount_ADT warning samples: TP2 ## percent.mt warning samples: TP3 out custom metrics # Metrics of interest can be selected to output freely viewable interactive tables. interactive_table &lt;- FindSampleMetricsWarning( pbmc, metrics.by = c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;, &quot;nCount_ADT&quot;, &quot;nFeature_ADT&quot;, &quot;percent.mt&quot;, &quot;percent.isotype&quot;, &quot;TCR%&quot;), type = c(&quot;lower&quot;, &quot;lower&quot;, &quot;lower&quot;, &quot;lower&quot;, &quot;higher&quot;, &quot;higher&quot;, &quot;lower&quot;), log = c(TRUE, TRUE, TRUE, TRUE, FALSE, FALSE, FALSE), nmads = c(3, 3, 3, 3, 3, 3, 3), return.type = &quot;interactive_table&quot; ) ## nCount_RNA warning samples: TP3 ## nFeature_RNA warning samples: TP3 ## nCount_ADT warning samples: TP2 ## percent.mt warning samples: TP3 ## TCR% warning samples: TP3 interactive_table Group by None Metrics Sample Download as CSV Metrics warning results (MAD Statistics) 3.1.3 Visualisation of V(D)J data pct: for the percentage of chain type The input object must be a Seurat object containing V(D)J information, which can be obtained using the ‘CalculateMetrics’ function. # Demonstration of anomalies in the V(D)J data # When viewing the results, it is necessary to display them in a second level, e.g. ‘plot_list$TCR’. plot_list &lt;- PlotSampleVDJ(pbmc, type=&quot;pct&quot;, return.type = &quot;plot&quot;) ## &gt; - 0 TRA% &gt; TRB% samples, 4 TRA% &lt;= TRB% samples. ## &gt; - 0 IGH% &gt; (IGK+IGL)% samples, 4 IGH% &lt;= (IGK+IGL)% samples. ## &gt; - 1 BCR% &gt; TCR% samples : `TP3` names(plot_list) ## [1] &quot;TCR&quot; &quot;BCR&quot; &quot;VDJ&quot; plot_list$VDJ # interactive table out &lt;- PlotSampleVDJ(pbmc, type=&quot;pct&quot;, return.type = &quot;interactive_table&quot;) ## &gt; - 0 TRA% &gt; TRB% samples, 4 TRA% &lt;= TRB% samples. ## &gt; - 0 IGH% &gt; (IGK+IGL)% samples, 4 IGH% &lt;= (IGK+IGL)% samples. ## &gt; - 1 BCR% &gt; TCR% samples : `TP3` # out$base stores the sample base information for the V(D)J chain. out$base Download as CSV V(D)J chain # out$statistics stores the summary information for the V(D)J chain. out$statistics Download as CSV V(D)J chain summary table subtype: for the percentage of chain subtype The input object must be a Seurat object containing V(D)J information, which can be obtained using the ‘CalculateMetrics’ function. # Distribution of receptor subtype occupancy among samples out&lt;-PlotSampleVDJ(pbmc, type=&quot;subtype&quot;, return.type = &quot;plot&quot;) out # interactive table out &lt;- PlotSampleVDJ(pbmc, type=&quot;subtype&quot;, return.type = &quot;interactive_table&quot;) # out$base stores information about the receptor subtypes of the V(D)J data out$base Download as CSV VDJ subtype # out$statistics stores summary information about receptor subtypes for V(D)J data out$statistics Download as CSV VDJ subtype summary table If the type parameter is set to “CDR3”, “clonalQuant”, “clonalOverlap”, or “geneUsage”, the input must be a list generated by the Read10XData function and preprocessed using the scRepertoire package. # Reading of V(D)J data dir_TCR &lt;- c( &quot;/data/SingleCellMQC/CellRanger/TP1/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP2/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3/vdj_t/filtered_contig_annotations.csv&quot;, &quot;/data/SingleCellMQC/CellRanger/TP3-rep/vdj_t/filtered_contig_annotations.csv&quot; ) sample_name &lt;- c(&quot;TP1&quot;, &quot;TP2&quot;, &quot;TP3&quot;, &quot;TP3-rep&quot;) VDJ_data &lt;- Read10XData(dir_TCR = dir_TCR, sample = sample_name) CDR3: for the length distribution of the CDR3 sequences The input object must be a raw list of “filtered_contig_annotations” data as input, details see clonalLength function from scRepertoire package. # CDR3 length visualisation out&lt;-PlotSampleVDJ(VDJ_data, type=&quot;CDR3&quot;, return.type = &quot;plot&quot;) out clonalQuant: or quantifying unique clonotypes The input object must be a raw list of “filtered_contig_annotations” data as input, details see clonalQuant function from scRepertoire package. # CDR3 length visualisation out&lt;-PlotSampleVDJ(VDJ_data, type=&quot;clonalQuant&quot;, return.type = &quot;plot&quot;) out clonalOverlap: for quantifying unique clonotypes The input object must be a raw list of “filtered_contig_annotations” data as input, details see clonalOverlap function from scRepertoire package. # clonalOverlap visualisation out&lt;-PlotSampleVDJ(VDJ_data, type=&quot;clonalOverlap&quot;, return.type = &quot;plot&quot;) out # interactive table out &lt;- PlotSampleVDJ(VDJ_data, type=&quot;clonalOverlap&quot;, return.type = &quot;interactive_table&quot;) out Download as CSV Morisita geneUsage: for the proportion of V gene usage The input object must be a raw list of “filtered_contig_annotations” data as input, details see percentGenes function from scRepertoire package. # GeneUsage visualisation PlotSampleVDJ(VDJ_data, type=&quot;geneUsage&quot;, return.type = &quot;plot&quot;) # interactive_table out &lt;- PlotSampleVDJ(VDJ_data, type=&quot;geneUsage&quot;, return.type = &quot;interactive_table&quot;) out Download as CSV geneUsage 3.2 PCT outlier sample detection Outlier sample detection in SingleCellMQC focuses on identifying deviations in cell type composition. Deviations in cell type composition within samples from the same experimental group are often indicative of potential technical issues, such as prolonged processing time, variations in storage conditions, experimental processing errors, and batch effects, all of which can compromise the integrity of the data. To address this issue, SingleCellMQC incorporates cell type composition analysis as a additional outlier detection approach. This section include two main approaches: 1) Common range outliers: Comparison of predicted results with cell proportion range database; 2) Inter-sample outliers: Identifying deviations in cell type composition. 3.2.1 Cell type annotation (ScType) The data needs to be performed automatic cell annotation, selecting either the “Main” or “ScType” or “Cell_Taxonomy” database for annotation in RunScType(). The “Main” database is annotated by default and contains T cells, B cells, NK cells, DC cells, Mon / Mac cells, endothelial cells, fibroblasts, granulocytes and other cells (erythrocytes, epithelial cells, etc.). # To view the types of organisations included in the Cell_Taxonomy database head(ShowDatabaseTissue(database=&quot;Cell_Taxonomy&quot;)) ## [1] &quot;Brain&quot; &quot;Embryo&quot; &quot;Ovary&quot; &quot;Prostate gland&quot; NA &quot;Blood&quot; # To view the types of organisations included in the ScType database head(ShowDatabaseTissue(database = &quot;ScType&quot;)) ## [1] &quot;Immune system&quot; &quot;Pancreas&quot; &quot;Liver&quot; &quot;Eye&quot; &quot;Kidney&quot; &quot;Brain&quot; # For each sample, the cells were annotated separately. pbmc &lt;- RunScType(pbmc, split.by=&quot;orig.ident&quot;, data_source = &quot;Main&quot;) # The results are stored in the ScType column of meta.data table(pbmc@meta.data$ScType) ## ## B cell DC Mon/Mac NK Other T cell ## 3436 460 5653 5059 2522 11368 3.2.2 Comparison of predicted results with cell proportion range database This section provides a summary of the common range outliers based on cell type composition. Outlier samples can be identified by comparing their cell type composition with our established reference cell type composition ranges when performing the FindCommonPCTOutlier function. The reference cell type composition ranges are established based on the 2299 single cell samples from DISCO database. ShowCommonPCTTissue() FindCommonPCTOutlier() can be used to determine if the sample is out of scale with the database and output the outlier sample. Currently only auto-annotated results from the Main database are supported. FindCommonPCTOutlier(pbmc, tissue = &quot;blood&quot;, return.type = &quot;interactive_table&quot;, celltype.by = &quot;ScType&quot;) ## T cell outlier samples: TP3 ## B cell outlier samples: TP3 ## Other outlier samples: TP2,TP3 Group by All isOutlier CellType Sample Download as CSV Common range outlier results 3.2.3 Inter-sample outliers A PCA-based outlier detection method using confidence ellipse or Density-Based Spatial Clustering of Applications with Noise (DBSCAN) to identify samples with unusual cell type proportions within sample groups was also provided in this section. Additionally, contributions of each cell type composition to PCs were calculated, providing further insights into potential outliers and ensuring the reliability of the dataset for downstream analysis. Flag samples with unusual proportions of cell types within sample groups: confidence ellipse # Identify outliers using the confidence ellipse # Use return.type to specify the type of output, including table, plot and interactive table out &lt;- FindInterSamplePCTOutlier(pbmc, method = &quot;ellipse&quot;, confidence_level = 0.95, return.type = &quot;plot&quot;) ## Outlier samples: # PCA plot out$pca # contributions of cell type compositions to PCs out$contrib_pc1 out$contrib_pc2 DBSCAN out &lt;- FindInterSamplePCTOutlier(pbmc, method = &quot;dbscan&quot;, return.type = &quot;plot&quot;) ## Outlier samples: TP3 # PCA plot out$pca # interactive table out &lt;- FindInterSamplePCTOutlier(pbmc, celltype.by = &quot;ScType&quot;, sample.by = &quot;orig.ident&quot;, return.type=&quot;interactive_table&quot;) ## Outlier samples: # Cell PCT Outlier results are shown in the out$outlier. out$outlier Download as CSV Cell PCT Outlier results # Countribution of groups to PCs are shown in the out$contribution. out$contribution Download as CSV Contribution of groups to PCs 3.2.4 Outlier detection for metrics with different cell types # Visualisation of the results outlier_result &lt;- FindSampleMetricsWarning(pbmc, split.by=&quot;ScType&quot;, sample.by = &quot;orig.ident&quot;,return.type=&quot;plot&quot;) ## &gt;&gt;&gt;&gt;&gt;&gt; B cell ## nCount_ADT warning samples: TP2 ## percent.mt warning samples: TP3 ## &gt;&gt;&gt;&gt;&gt;&gt; DC ## percent.mt warning samples: TP3 ## &gt;&gt;&gt;&gt;&gt;&gt; Mon/Mac ## nFeature_RNA warning samples: TP3 ## percent.mt warning samples: TP3 ## percent.isotype warning samples: TP3 ## &gt;&gt;&gt;&gt;&gt;&gt; NK ## percent.mt warning samples: TP3 ## &gt;&gt;&gt;&gt;&gt;&gt; Other ## nFeature_ADT warning samples: TP2 ## &gt;&gt;&gt;&gt;&gt;&gt; T cell ## nCount_ADT warning samples: TP2 ## percent.mt warning samples: TP3 # The metrics of interest can be selected to be displayed outlier_result[[&quot;T cell&quot;]] # interactive table outlier_result &lt;- FindSampleMetricsWarning(pbmc, split.by=&quot;ScType&quot;, sample.by = &quot;orig.ident&quot;,return.type=&quot;interactive_table&quot;) ## &gt;&gt;&gt;&gt;&gt;&gt; B cell ## nCount_ADT warning samples: TP2 ## percent.mt warning samples: TP3 ## &gt;&gt;&gt;&gt;&gt;&gt; DC ## percent.mt warning samples: TP3 ## &gt;&gt;&gt;&gt;&gt;&gt; Mon/Mac ## nFeature_RNA warning samples: TP3 ## percent.mt warning samples: TP3 ## percent.isotype warning samples: TP3 ## &gt;&gt;&gt;&gt;&gt;&gt; NK ## percent.mt warning samples: TP3 ## &gt;&gt;&gt;&gt;&gt;&gt; Other ## nFeature_ADT warning samples: TP2 ## &gt;&gt;&gt;&gt;&gt;&gt; T cell ## nCount_ADT warning samples: TP2 ## percent.mt warning samples: TP3 # The metrics of interest can be selected to be displayed outlier_result Group by None Metrics Sample Download as CSV Metrics outlier results (MAD Statistics) 3.2.5 Visualisation of the PCT of cell types Based on the results of the automatic cell annotation, visualisation of cell proportions can be performed, including stacked plots, histograms and interaction tables. # Stacked Bar Chart for all cell types PlotSampleCellTypePCT(pbmc, sample.by = &quot;orig.ident&quot;, celltype.by = &quot;ScType&quot;, plot.type=&quot;stackbar&quot;) # Bar graphs for each cell type PlotSampleCellTypePCT(pbmc, sample.by = &quot;orig.ident&quot;, celltype.by = &quot;ScType&quot;, plot.type = &quot;bar&quot;) # interactive table PlotSampleCellTypePCT(pbmc, sample.by = &quot;orig.ident&quot;, celltype.by = &quot;ScType&quot;, return.type=&quot;interactive_table&quot;) Download as CSV CellType% per Sample 3.3 Sample identity verification To avoid potential recording mistakes and data transmission errors, checking whether the file labeling is consistent with analyzed data features is necessary at the beginning of sample QC. By default, you can check if your sample gender information is incorrectly labeled. In addition, if your sample does not have gender information, you can get it according to the table below. Use PlotSampleLabel() to visualise the percentage of gene expression, with gender-related genes set as the default. # interactive table out&lt;-PlotSampleLabel(pbmc, return.type = &quot;interactive_table&quot; ) out Download as CSV The pct of features It is possible to customise the gender-related genes to be analysed, e.g. “Female=‘XIST’, Male=c(‘DDX3Y’, ‘UTY’)”,store them with the “feature_list”. "],["cell-qc.html", "4 Cell QC 4.1 Empty droplets detection (If Required) 4.2 Low quality cells detection 4.3 Check low-quality cells (optional) 4.4 Doublets detection 4.5 Visualization of cell QC results 4.6 Filter out problematic droplets or cells", " 4 Cell QC Compiled: 2025-05-08 Written by Jiaying Zeng and Daihan Ji library(SingleCellMQC) #Load a pre-existing Seurat object or process raw data using SingleCellMQC. pbmc &lt;- readRDS(&quot;/data/pbmc.rds&quot;) The cell-level QC in SingleCellMQC includes the identification of (i) empty droplets, (ii) doublets, and (iii) low-quality cells. By integrating a variety of publicly available tools and in-house developed QC strategies, the cell QC module provides a systematic framework to detect and remove problematic droplets or cells across multiple omics layers. Where can you view the results of cell-level QC? You can explore them in pbmc@meta.data or pbmc@misc[[\"SingleCellMQC\"]][[\"perQCMetrics\"]][[perCell]],pbmc@misc[[\"SingleCellMQC\"]][[\"LowQuality\"]],pbmc@misc[[\"SingleCellMQC\"]][[\"Doublet\"]]. 4.1 Empty droplets detection (If Required) Generally, count matrix files generated from single-cell preprocessing tools such as Cell Ranger and dnbc4tools have already undergone empty droplet removal. However, if users wish to perform this step themselves, SingleCellMQC implements empty droplet detection based on scRNA-seq data using the dropletUtils package. # Empty droplets detection (DropletUtils) out &lt;- RunEmptyDroplet(dir_name=&quot;/data/raw/&quot;) 4.2 Low quality cells detection Before you conduct low quality cells detection, ensure that you have run CalculateMetrics. 4.2.1 Fixed cutoff In this method, you can filter out low-quality cells by setting a fixed cutoff for certain cell QC metrics. Before choosing a suitable cutoff, you can use GetMetricsRange to obtain the commonly used cutoff for the corresponding tissue. The cutoffs for each QC parameter was obtained by 240 single-cell studies spanning 11 human tissues. Here, we take “blood” as an example. cutoff_plot &lt;- GetMetricsRange(tissue = &quot;blood&quot;) cutoff_plot$MT cutoff_plot$nCount_min cutoff_plot$nCount_max Alternatively, you can visualize cell QC metrics using regular violin plots, and manually select appropriate cutoffs by yourself. # View the cell QC metrics, such as percentage of mitochondria. PlotCellMetrics(pbmc, metrics =&quot;percent.mt&quot; , log.y = F ) Then you can select your cutoff to set a fixed threshold to mark low-quality cells. pbmc &lt;- RunLQ_fixed(pbmc, percent.mt = 10, min.nCount_RNA=500, min.nFeature_RNA= 200) # Show the number of low-quality cells marked. table(pbmc$lq_fixed, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 401 936 1803 473 ## Pass 9735 8127 1894 5129 4.2.2 MAD method You can use SingleCellMQC to automatically identify low-quality cells by calculating outliers for RNA metrics (nCount_RNA, nFeature_RNA, percent.mt) and ADT metrics (nCount_ADT, nFeature_ADT, percent.isotype) using the Median Absolute Deviation (MAD) method. # `split.by` can be set to sample or batch information, etc., to explore the number of low-quality cells detected in different groups. # The `nmads` parameter is usually set to 3. pbmc &lt;- RunLQ_MAD(pbmc, split.by = &quot;orig.ident&quot;, nmads = 3) table(pbmc$lq_RNA_gene_3mad, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 621 449 53 481 ## Pass 9515 8614 3644 5121 table(pbmc$lq_RNA_mt_3mad, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 787 1218 565 808 ## Pass 9349 7845 3132 4794 4.2.3 miQC method Other publicly available tools for low-quality cells detection are integrated in this part. The miQC method is one of them. You can turn to reference and github link for more detailed information. # `split.by` can be set to sample or batch information, etc. pbmc &lt;- RunLQ_miQC(pbmc, split.by = &quot;orig.ident&quot;) table(pbmc$lq_miQC, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 753 1255 869 977 ## Pass 9383 7808 2828 4625 4.2.4 ddqc method The ddqc method is another publicly available tool. You can turn to reference and github link for more detailed information. # `split.by` can be set to sample or batch information, etc. pbmc &lt;- RunLQ_ddqc(pbmc, split.by = &quot;orig.ident&quot;) table(pbmc$lq_ddqc, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 298 500 230 223 ## Pass 9838 8563 3467 5379 4.2.5 Run multiple methods Use RunLQ and list the methods you want in the methods parameter. pbmc &lt;- RunLQ(pbmc, split.by = &quot;orig.ident&quot;, methods=c(&quot;MAD&quot;, &quot;miQC&quot;) ) 4.3 Check low-quality cells (optional) To minimize false positives, SingleCellMQC allows re-clustering of flagged cells based on their expression profiles before removal. This step helps identify biologically relevant cell populations that may exhibit outlier QC metrics due to molecular expression variability rather than poor quality, and these cells are rescued and retained for downstream analysis. # pbmc &lt;- RunLQ_fixed(pbmc, min.nFeature_RNA = 200, min.nCount_RNA = 500, percent.mt = 10) # For `method_column` parameter, enter the colnames of the result of previous methods that you want to re-cluster, such as &quot;lq_Fixed&quot;. out &lt;- RunLQReClustering(pbmc, method_column = c(&quot;lq_fixed&quot;),cluster_resolution = 1) After the re-clustering is completed, the following three parts can be used to confirm the cell identity and check whether there are any missed cell groups. Use COSG method to find markers in each low-quality cluster, assisting in cell identity determination. COSG_marker &lt;- FindAllMarkerCOSG(LQ_result, cluster.by = &quot;seurat_clusters&quot;) head(COSG_marker) ## gene cluster cosg avg_logFC meanlog_1 meanlog_2 pct_1 pct_2 ## GNLY GNLY Fail_4 0.321 1.826 3.1322 1.3065 0.6639 0.1033 ## MATK MATK Fail_4 0.219 1.028 1.2990 0.2708 0.2389 0.0384 ## SPON2 SPON2 Fail_4 0.198 1.202 1.7013 0.4992 0.3444 0.0621 ## SYNE1 SYNE1 Fail_4 0.197 1.177 2.1275 0.9501 0.5333 0.1491 ## CCL5 CCL5 Fail_4 0.187 1.301 2.7265 1.4259 0.6583 0.1589 ## SYTL2 SYTL2 Fail_4 0.182 0.956 1.3290 0.3731 0.2500 0.0504 Call ClusterProfiler package to perform pathway enrichment analysis to view the pathways of each low-quality cluster, assisting in cell identity determination. PlotMarkerEnrichKegg(cosg_marker = COSG_marker) Perform ScType annotation to assist in determining cell identities. Cells labeled as “Unknown” are more likely to represent low-quality cells. LQ_result &lt;- RunScType(LQ_result, data_source =&quot;ScType&quot;) PlotReducedDim(LQ_result, group.by = &quot;seurat_clusters&quot;)+ PlotReducedDim(LQ_result, group.by = &quot;ScType&quot;) 4.4 Doublets detection For doublets detection, SingleCellMQC integrates five widely used RNA expression-based methods, including DoubletFinder, scDbFinder, cxds, bcds, hybrid, one V(D)J chain based method on TCR/BCR sequencing data, along with one in-house developed multi-omics strategy based on surface protein expression (ADT-based). 4.4.1 scDblFinder method The scDblFinder method is one of the publicly available tools for doublets detection. You can turn to reference and github link for more detailed information. # The `split.by` parameter must refer to your sample. # The `add.Seurat` parameter means whether you want to add results in the Seurat object. pbmc&lt;- RunDbt_scDblFinder(pbmc, split.by = &quot;orig.ident&quot;, add.Seurat=T, do.topscore=T) table(pbmc$db_scDblFinder, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 821 657 109 251 ## Pass 9315 8406 3588 5351 head(pbmc$db_scDblFinder_score) ## TP1_AAACCTGAGAATGTTG-1 TP1_AAACCTGAGCCCTAAT-1 TP1_AAACCTGAGGACTGGT-1 TP1_AAACCTGCAAGCGATG-1 TP1_AAACCTGCAATGGAGC-1 TP1_AAACCTGCACAGTCGC-1 ## 0.0060459864 0.9996028543 0.0016912580 0.0008436530 0.9318320155 0.0001187744 4.4.2 hybrid method The hybrid method is one of the publicly available tools for doublets detection. You can turn to reference and github link for more detailed information. # The `split.by` parameter must refer to your sample. # The `add.Seurat` parameter means whether you want to add results in the Seurat object. pbmc&lt;- RunDbt_hybrid(pbmc, split.by = &quot;orig.ident&quot;, add.Seurat=T) table(pbmc$db_hybrid, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 821 657 109 251 ## Pass 9315 8406 3588 5351 head(pbmc$db_hybrid_score) ## TP1_AAACCTGAGAATGTTG-1 TP1_AAACCTGAGCCCTAAT-1 TP1_AAACCTGAGGACTGGT-1 TP1_AAACCTGCAAGCGATG-1 TP1_AAACCTGCAATGGAGC-1 TP1_AAACCTGCACAGTCGC-1 ## 0.3104272 1.7186222 0.2577161 0.2417090 1.0813173 0.0843216 4.4.3 bcds method The bcds method is one of the publicly available tools for doublets detection. You can turn to reference and github link for more detailed information. # The `split.by` parameter must refer to your sample. # The `add.Seurat` parameter means whether you want to add results in the Seurat object. pbmc&lt;- RunDbt_bcds(pbmc, split.by = &quot;orig.ident&quot;, add.Seurat=T) table(pbmc$db_bcds, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 821 657 109 251 ## Pass 9315 8406 3588 5351 head(pbmc$db_bcds_score) ## TP1_AAACCTGAGAATGTTG-1 TP1_AAACCTGAGCCCTAAT-1 TP1_AAACCTGAGGACTGGT-1 TP1_AAACCTGCAAGCGATG-1 TP1_AAACCTGCAATGGAGC-1 TP1_AAACCTGCACAGTCGC-1 ## 0.01293355 0.93673164 0.02887737 0.02212005 0.80253756 0.01673022 4.4.4 cxds method The cxds method is one of the publicly available tools for doublets detection. You can turn to reference and github link for more detailed information. # The `split.by` parameter must refer to your sample. # The `add.Seurat` parameter means whether you want to add results in the Seurat object. pbmc&lt;- RunDbt_cxds(pbmc, split.by = &quot;orig.ident&quot;, add.Seurat=T) table(pbmc$db_cxds, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 821 657 109 251 ## Pass 9315 8406 3588 5351 head(pbmc$db_cxds_score) ## TP1_AAACCTGAGAATGTTG-1 TP1_AAACCTGAGCCCTAAT-1 TP1_AAACCTGAGGACTGGT-1 TP1_AAACCTGCAAGCGATG-1 TP1_AAACCTGCAATGGAGC-1 TP1_AAACCTGCACAGTCGC-1 ## 160102.42 497734.06 147398.61 145724.55 212804.72 46557.39 4.4.5 DoubletFinder method The DoubletFinder method is one of the publicly available tools for doublets detection. You can turn to reference and github link for more detailed information. # The `split.by` parameter must refer to your sample. # The `add.Seurat` parameter means whether you want to add results in the Seurat object. pbmc&lt;- RunDbt_DoubletFinder(pbmc, split.by = &quot;orig.ident&quot;, add.Seurat=T) table(pbmc$db_DoubletFinder, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 821 657 109 251 ## Pass 9315 8406 3588 5351 head(pbmc$db_DoubletFinder_score) ## TP1_AAACCTGAGAATGTTG-1 TP1_AAACCTGAGCCCTAAT-1 TP1_AAACCTGAGGACTGGT-1 TP1_AAACCTGCAAGCGATG-1 TP1_AAACCTGCAATGGAGC-1 TP1_AAACCTGCACAGTCGC-1 ## 0.1684285 0.3484848 0.1758280 0.1370684 0.2152925 0.2026075 4.4.6 VDJ method The VDJ-based strategy can identify homotypic doublets by detecting multi-chain cells. In immune repertoire sequencing, cells with multiple TCR or BCR chains (or both) are flagged as potential doublets. # The premise is that you have VDJ data and it has been processed by the `runMetrics` function. pbmc&lt;- RunDbt_VDJ(pbmc, add.Seurat=T) table(pbmc$db_VDJ, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 306 259 63 136 ## Pass 2956 2981 1107 2163 4.4.7 ADT method The ADT-based strategy can identify heterotypic doublets by analyzing mutually exclusive surface markers in ADT sequencing. This ADT-based method calculates positive expression thresholds for each surface protein. Cells with both expressions of exclusive paired surface markers were considered as doublets (Details see our manuscript). Users can customize exclusive surface marker pairs to target specific cell types based on their experiment needs, such as CD19 and CD3, which differentiate B and T cells. Here we take CD20/CD3 and CD19/CD3 as examples. You can use the ADT method to detect doublets. In default mode, ADT-based clustering is applied. pbmc &lt;- RunDbt_ADT(pbmc, split.by = &quot;orig.ident&quot;, add.Seurat =T, feature1 = c(&quot;Hu.CD20-2H7&quot;,&quot;Hu.CD19&quot;), feature2 = c(&quot;Hu.CD3-UCHT1&quot;,&quot;Hu.CD3-UCHT1&quot;)) table(pbmc$db_ADT, pbmc$orig.ident) ## ## TP1 TP2 TP3 TP3-rep ## Fail 87 165 153 75 ## Pass 10049 8898 3544 5527 If you are concerned about the impact of protein background noise, you can use the do.correct parameter to call the scCDC package to denoise the ADT data. pbmc&lt;- RunDbt_ADT(pbmc, feature1 = c(&quot;Hu.CD20-2H7&quot;,&quot;Hu.CD19&quot;), feature2 = c(&quot;Hu.CD3-UCHT1&quot;,&quot;Hu.CD3-UCHT1&quot;), split.by = &quot;orig.ident&quot;, preprocess = &quot;rna.umap&quot;, do.correct = T) What if you want to return the threshold of expression levels used to distinguish between negative and positive cell populations? # Calculate the cutoff of doublets cutoff &lt;- RunDbt_ADT(pbmc, feature1 = c(&quot;Hu.CD20-2H7&quot;,&quot;Hu.CD19&quot;), feature2 = c(&quot;Hu.CD3-UCHT1&quot;,&quot;Hu.CD3-UCHT1&quot;), return.cutoff = T, split.by = &quot;orig.ident&quot;) head(cutoff) ## Sample cluster_num resolution feature1 cutoff1 feature2 cutoff2 ## 1 TP1 24 1.5 Hu.CD20-2H7 0.7860469 Hu.CD3-UCHT1 1.178921 ## 2 TP1 24 1.5 Hu.CD19 0.7283664 Hu.CD3-UCHT1 1.178921 ## 3 TP2 24 1.5 Hu.CD20-2H7 0.8705569 Hu.CD3-UCHT1 1.029872 ## 4 TP2 24 1.5 Hu.CD19 0.5773097 Hu.CD3-UCHT1 1.029872 ## 5 TP3 21 1.5 Hu.CD20-2H7 0.8418260 Hu.CD3-UCHT1 1.227219 ## 6 TP3 21 1.5 Hu.CD19 0.5099738 Hu.CD3-UCHT1 1.227219 # Check out the results of TP1 PlotADTCutoff(pbmc, cutoff, feature1 = &quot;Hu.CD20-2H7&quot;, feature2 = &quot;Hu.CD3-UCHT1&quot;, Sample=&quot;TP1&quot;, group.by = &quot;chain_pair&quot;) 4.4.8 Run multiple methods Use RunDbt and list the methods you want in the methods parameter. pbmc&lt;- RunDbt(pbmc, split.by = &quot;orig.ident&quot;, add.Seurat=T, methods= c(&quot;scDblFinder&quot;, &quot;bcds&quot;),do.topscore=T ) 4.5 Visualization of cell QC results 4.5.1 Visualization of the percentage of cells filtered by different methods # Choose the detection session you want in `type.detection` parameter, including &quot;lq&quot; for low-quality cells and &quot;db&quot; for doublets. # Plotting the percentage of cells filtered by low-quality cell detection methods PlotCellMethodFiltration(pbmc, type.detection = &quot;lq&quot;, return.type = &quot;plot&quot;) # Plotting the percentage of cells filtered by doublet detection methods PlotCellMethodFiltration(pbmc, type.detection = &quot;db&quot;, return.type = &quot;plot&quot;) # Plotting interactive table interactive_table &lt;- PlotCellMethodFiltration(pbmc, type.detection = &quot;lq&quot;, return.type = &quot;interactive_table&quot;) interactive_table$pct ##Show filtered percentages Download as CSV Low quality cell filtered percentage interactive_table$count ##Show filtered counts Download as CSV Low quality cell filtered number 4.5.2 Overlap between different methods (UpSet plot) Low-quality cell results as an example, the same applies to doublet methods. # Plotting overlap of low-quality cell detection methods (all samples). PlotCellMethodUpset(pbmc, type.detection = &quot;lq&quot;) # Plotting overlap of low-quality cell detection methods (each sample). # Choose the column representing your sample for the `split.by` parameter. out &lt;- PlotCellMethodUpset(pbmc, type.detection = &quot;lq&quot;, split.by = &quot;orig.ident&quot;) names(out) ## [1] &quot;TP1&quot; &quot;TP2&quot; &quot;TP3&quot; &quot;TP3-rep&quot; out$TP1 4.5.3 Comparison of metrics between Pass and Fail cells identified by methods Taking percentage of percent.mt of low-quality cells as an example, the same applies to other metrics and doublets. # Plotting comparison of low-quality cell detection methods (all samples). PlotCellMethodVln(pbmc, metrics.by = &quot;percent.mt&quot;, type.detection = &quot;lq&quot;) # Plotting comparison of low-quality cell detection methods (each sample). # Choose the column representing your sample for the `split.by` parameter. out &lt;- PlotCellMethodVln(pbmc, metrics.by = &quot;percent.mt&quot;, type.detection = &quot;lq&quot;, split.by = &quot;orig.ident&quot;) names(out) ## [1] &quot;TP1&quot; &quot;TP2&quot; &quot;TP3&quot; &quot;TP3-rep&quot; out$TP1 4.5.4 Visualization of scatter plots for cell metrics You can view two metrics simultaneously in 2D mode. # Overall visualization of cell metrics PlotCellMetricsScatter(pbmc, metrics.by = c(&quot;percent.mt&quot;, &quot;nFeature_RNA&quot;) , log.x = T, log.y = T) # Visualization of cell metrics for certain detection method, like `lq_fixed` PlotCellMetricsScatter(pbmc, metrics.by = c(&quot;percent.mt&quot;, &quot;nFeature_RNA&quot;) , log.x = T, log.y = T, group.by = &quot;lq_fixed&quot;) # Visualization of cell metrics for certain detection method in each sample # PlotCellMetricsScatter(pbmc, metrics.by = c(&quot;percent.mt&quot;, &quot;nFeature_RNA&quot;) , log.x = T, log.y = T, group.by = &quot;lq_fixed&quot;, split.by=&quot;orig.ident&quot;) You can view three metrics simultaneously in 3D mode. # Overall visualization of cell metrics PlotCellMetricsScatter(pbmc, metrics.by = c(&quot;percent.mt&quot;, &quot;nFeature_RNA&quot;,&quot;nCount_RNA&quot;) , log.x = T, log.y = T) # Visualization of cell metrics for certain detection method, like `lq_fixed` PlotCellMetricsScatter(pbmc, metrics.by = c(&quot;percent.mt&quot;, &quot;nFeature_RNA&quot;,&quot;nCount_RNA&quot;) , log.x = T, log.y = T, group.by = &quot;lq_fixed&quot;) # Visualization of cell metrics for certain detection method in each sample # PlotCellMetricsScatter(pbmc, metrics.by = c(&quot;percent.mt&quot;, &quot;nFeature_RNA&quot;,&quot;nCount_RNA&quot;) , log.x = T, log.y = T, group.by = &quot;lq_fixed&quot;, split.by=&quot;orig.ident&quot;) 4.6 Filter out problematic droplets or cells After executing the above steps, you can choose the filtering strategy you need. For example, you can select the results from lq_RNA_mt_3mad and db_scDblFinder to filter out the cells marked as Fail. pbmc &lt;- FilterCells(pbmc, filter_columns = c(&quot;lq_RNA_mt_3mad&quot;, &quot;db_scDblFinder&quot;), filter_logic = &quot;or&quot;) If you want to filter out the Fail cells that are in the intersection of multiple methods, such as db_scDblFinder and db_hybrid, you can change the filter_logic to “and”. pbmc &lt;- FilterCells(pbmc, filter_columns = c(&quot;db_scDblFinder&quot;, &quot;db_hybrid&quot;), filter_logic = &quot;and&quot;) If you want to return the specific count values of each sample before and after filtering, take lq_RNA_mt_3mad for example. out &lt;- FilterCells(pbmc, filter_columns = c(&quot;lq_RNA_mt_3mad&quot;, &quot;db_scDblFinder&quot;), filter_logic = &quot;or&quot;, return.table = T, split.by = &quot;orig.ident&quot;) ## Total cells before filtering: 28498 ## Total cells after filtering: 23344 ## &gt;&gt;&gt;&gt; Sample: TP1 ## Cells before filtering: 10136 ## Cells after filtering: 8549 ## &gt;&gt;&gt;&gt; Sample: TP2 ## Cells before filtering: 9063 ## Cells after filtering: 7220 ## &gt;&gt;&gt;&gt; Sample: TP3 ## Cells before filtering: 3697 ## Cells after filtering: 3023 ## &gt;&gt;&gt;&gt; Sample: TP3-rep ## Cells before filtering: 5602 ## Cells after filtering: 4552 out ## Sample Before_Filtering After_Filtering ## 1 Total 28498 23344 ## 2 TP1 10136 8549 ## 3 TP2 9063 7220 ## 4 TP3 3697 3023 ## 5 TP3-rep 5602 4552 "],["feature-qc.html", "5 Feature QC 5.1 Feature quality assessment 5.2 Systematic background noise correction", " 5 Feature QC Compiled: 2025-05-08 Written by Shuting Lu and Daihan Ji library(SingleCellMQC) library(BPCells) #Load a pre-existing Seurat object or process raw data using SingleCellMQC. pbmc &lt;- readRDS(&quot;/data/pbmc.rds&quot;) The main tasks of feature-level QC include: Feature quality assessment- Focused on identifying and removing low-expression features with abnormal variability. Systematic background noise correction- Aimed at detecting and removing contaminations from ambient RNA and nonspecific antibody binding. 5.1 Feature quality assessment The feature quality assessment module in SingleCellMQC calculates QC metrics for both RNA and surface protein (ADTs) features. For RNA, key metrics include average expression level, expression standardized variance, and the detection rate across all cells. For surface protein features (ADTs), QC metrics include the detection rate of each antibody-derived tag across cells, expression level, expression standardized variance. 5.1.1 Calculating feature metrics The first step in this module is to calculate the relevant metrics for the feature and adjust the option of adding it to the Seurat object. If no SeuratObject is added, sample.by is the sample column that can be selected, and the result will return the outcome of the metric calculation for each sample and for all samples. If several samples result in a large amount of data, it is recommended to store them separately to avoid the original Seurat object taking up too much space. # Without adding the Seurat object feature_metrics &lt;- CalculateMetricsPerFeature(pbmc, add.Seurat = F, sample.by=&quot;orig.ident&quot;) # With the addition of the Seurat object pbmc&lt;- CalculateMetricsPerFeature(pbmc, add.Seurat = T, sample.by=&quot;orig.ident&quot;) Where can you view the results of feature-level QC? You can explore them in pbmc@misc[[\"SingleCellMQC\"]][[\"perQCMetrics\"]][[perFeature]]. 5.1.2 Reference QC thresholds for feature QC To filter low-quality features, SingleCellMQC offers the values for the minimum number of cells in which a feature is detected (nCell). These thresholds were determined using an integrative analysis of 240 public single-cell studies spanning 11 human tissues to adapt to different tissue types. cutoff_plot &lt;- GetMetricsRange(tissue = &quot;blood&quot;) cutoff_plot$nCell_min 5.1.3 Calculating per-feature variance explained by batch factors In this module, it supports identifying the potential genes/proteins that are most affected by batch factors or individual effects by calculating ANOVA-derived R² values. # Calculating per-feature variance explained by batch factor (Batch_TotalSeq_C_Antibodies). Seurat::DefaultAssay(pbmc) &lt;- &quot;ADT&quot; out &lt;- RunVarExplained(pbmc, assay = &quot;ADT&quot;, variables = c(&quot;Batch_TotalSeq_C_Antibodies&quot;)) # View of inter-individual top 10 influence level genes PlotVEPerFeature(out, plot.type=&quot;bar&quot;) ## $Batch_TotalSeq_C_Antibodies # interactive table PlotVEPerFeature(out, plot.type=&quot;bar&quot;, return.type = &quot;interactive_table&quot;, ntop = 10) Download as CSV Variance Explained per Feature (top 10) 5.1.4 Base plots of feature metrics Select the metric category to be displayed, such as type=“pct”, type=“variance.standardized”, etc. Visualisations such as density plots, bar graphs and interactive tables can be selected by specifying the “return.type”. feature_metrics &lt;- readRDS(&quot;/data/feature_metrics.rds&quot;) # Density and bar graphs PlotFeatureMetrics(feature_metrics, type=&quot;variance.standardized&quot;, return.type = &quot;plot&quot;, sample = &quot;All&quot;) # Metrics visualisation of Feature for specified samples. PlotFeatureMetrics(feature_metrics, type=&quot;pct&quot;, return.type = &quot;plot&quot;, sample = &quot;TP1&quot;) 5.1.5 Scatter plot of the feature metrics Specify the number of metrics to plot and choose between 2D and 3D in the Scatter plot. In a 3D scatterplot, the entire graph can be freely rotated. This makes it easier to see the relationships between individual metrics. # 2D Scatterplot PlotFeatureMetricsScatter(feature_metrics, metrics.by = c(&quot;pct&quot;, &quot;mean&quot;), sample = &quot;TP1&quot;) # 3D Scatterplot PlotFeatureMetricsScatter(feature_metrics, metrics.by = c(&quot;pct&quot;, &quot;mean&quot;,&quot;variance.standardized&quot;), sample = &quot;TP1&quot;) 5.2 Systematic background noise correction To address contamination from sources such as ambient RNA or nonspecific antibody binding, SingleCellMQC employs the ‘RunCorrection’ function for background noise correction using DecontX for RNA and DecontPro for ADT. For more targeted correction, this function also integrates scCDC to identify and remove highly contaminated RNAs or proteins, minimizing the risk of overcorrecting unaffected features. 5.2.1 scCDC Firstly the included features are detected, where group.by refers to the column name of the clustering, so before executing this function, you should clustering the clusters, for example by running the RunPipelinePerGroup() function. # If you do not have pre-existing cell clustering information, you can run RunPipeline or RunPipelinePerGroup to obtain cluster labels # RunPipeline per sample pbmc_list &lt;- RunPipelinePerGroup(pbmc, preprocess = &quot;rna.umap&quot;) # Contaminated features detection per sample HCF_out &lt;- FindContaminationFeature(pbmc_list, assay= &quot;RNA&quot;, group.by=&quot;seurat_clusters&quot;, restriction_factor=0.5, split.by = &quot;orig.ident&quot;) Perform background corrections on genes by entering the names of the genes to be corrected as features. These features can be global corrections based on HCF_out or partial corrections based on custom feature names. # RunCorrection_scCDC per sample based on HCF_out # Correct &lt;- RunCorrection_scCDC(pbmc_list, assay= &quot;RNA&quot;, features=HCF_out, split.by = &quot;orig.ident&quot; ) # RunCorrection_scCDC per sample based on custom features Correct &lt;- RunCorrection_scCDC(pbmc_list, assay= &quot;RNA&quot;, features= c(&quot;CD3D&quot;, &quot;CD3E&quot;, &quot;CD79A&quot;), split.by = &quot;orig.ident&quot; ) Although this method is designed for RNA data correction, it also performs well in the correction of ADT data in our PBMC dataset. 5.2.2 DecontX (RNA) # RunCorrection_DecontX per sample pbmc &lt;- RunCorrection_DecontX(pbmc, split.by = &quot;orig.ident&quot;) 5.2.3 DecontPro (ADT) For ADTs, DecontPro can also be used for background correction. # RunCorrection_DecontPro for TP3 sample TP3 &lt;- subset(pbmc, orig.ident %in% c(&quot;TP3&quot;) ) TP3 &lt;- RunPipeline(TP3, preprocess = &quot;adt.umap&quot;) pbmc &lt;- RunCorrection_DecontPro(TP3, group.by=&quot;adt_cluster&quot;) "],["batch-effect-evaluation.html", "6 Batch effect evaluation 6.1 Sample level 6.2 Cell level 6.3 Feature level", " 6 Batch effect evaluation Compiled: 2025-05-08 Written by Shuting Lu and Daihan Ji library(SingleCellMQC) library(BPCells) library(Seurat) #Load a pre-existing Seurat object or process raw data using SingleCellMQC. pbmc &lt;- readRDS(&quot;/data/pbmc.rds&quot;) Batch-to-batch variation is a significant challenge in single-cell analysis, where differences in protocols, reagents, and experimental conditions can introduce noise that obscures true biological signals and leads to misleading interpretations. To address this issue, SingleCellMQC evaluates batch effects at both sample and cell levels. 6.1 Sample level At the sample level, SingleCellMQC generates pseudobulk sample data by aggregating single-cell counts for target cell populations. PCA is then applied to identify batch effects across samples. In addition, SingleCellMQC performs singular value decomposition (SVD) analysis and calculates R² values to determine batch-associated variables that are significantly associated with principal components, providing insights into the main drivers of batch effects. 6.1.1 PCA of pseudobulk data at the sample level To visualize the distribution of antibody batches for RNA/ADT data, you can perform PCA on pseudobulk data by specifying plot.type = \"pseudobulk\" in the PlotReducedDim function. Here’s an example using the batch variable Batch_TotalSeq_C_Antibodies in ADT data: ## Perform PCA on pseudobulk ADT data, grouped by the batch variable: `Batch_TotalSeq_C_Antibodies` PlotReducedDim(pbmc , plot.type = &quot;pseudobulk&quot;, assay=&quot;ADT&quot;, group.by.pseudobulk = &quot;Batch_TotalSeq_C_Antibodies&quot;) 6.1.2 Performing SVD analysis and calculating R² values To further investigate factors contributing to batch effects, SingleCellMQC performed SVD analysis and calculated R² values to analyze batch-associated variables. The PCA results from the ‘prcomp’ function were analyzed via Kruskal-Wallis tests (categorical variables) or linear regression (continuous variables) to detect the significance of the relationship between the variable and the PC scores. Additionally, the proportion of variance explained by batch-associated variables was quantified for each feature using ANOVA-derived R² (categorical) or regression-based R² (continuous). For ADT data, the covariates \"nCount_ADT\", \"Batch_TotalSeq_C_Antibodies\", and \"Time_point\" are analyzed as follows: out &lt;- PlotCovariateImpact(pbmc, pseudobulk.sample.by = &quot;orig.ident&quot;, assay = &quot;ADT&quot;, variables = c(&quot;nCount_ADT&quot;, &quot;Batch_TotalSeq_C_Antibodies&quot;, &quot;Time_point&quot;)) # Verification of correlation between batch covariates and principal components. out$svd # Display of the extent to which batch covariates contribute to the principal components out$explanatory # Presentation of results with interactive tables out&lt;-PlotCovariateImpact(pbmc, variables =c(&quot;nCount_ADT&quot;, &quot;Batch_TotalSeq_C_Antibodies&quot;), assay = &quot;ADT&quot; , return.type = &quot;interactive_table&quot;) out$svd Download as CSV SVD significance pvalue out$explanatory Download as CSV Explanatory PCs for each variable If you want to analyze based on a specific column (e.g., cell type annotations), you can split the data by cell type. For instance, if you have run RunScType and obtained cell type annotations stored in the ScType column, you can perform SVD analysis and variance explanation (R²) for each sample split by cell type. out &lt;- PlotCovariateImpact(pbmc, pseudobulk.sample.by = &quot;orig.ident&quot;, assay = &quot;ADT&quot;, pseudobulk.celltype.by= &quot;ScType&quot;, variables = c(&quot;nCount_ADT&quot;, &quot;Batch_TotalSeq_C_Antibodies&quot;, &quot;Time_point&quot;), return.type = &quot;interactive_table&quot;) ## 2025-05-08 00:25:14-------- Split Seurat Object ## 2025-05-08 00:25:16 svd all ## 2025-05-08 00:25:17 svd B cell ## 2025-05-08 00:25:17 svd DC ## 2025-05-08 00:25:17 svd Mon/Mac ## 2025-05-08 00:25:18 svd NK ## 2025-05-08 00:25:18 svd Other ## 2025-05-08 00:25:19 svd T cell ## 2025-05-08 00:25:19 explanatory all ## 2025-05-08 00:25:20 explanatory B cell ## 2025-05-08 00:25:20 explanatory DC ## 2025-05-08 00:25:21 explanatory Mon/Mac ## 2025-05-08 00:25:21 explanatory NK ## 2025-05-08 00:25:22 explanatory Other ## 2025-05-08 00:25:22 explanatory T cell # Display of the correlation between the covariates of the batch and the principal component PC1 out$svd$PC1 Download as CSV SVD significance pvalue (PC1) # Display of the contribution of the batch covariates to the principal component PC1 out$explanatory$PC1 Download as CSV Explanatory PCs for each variable (PC1) 6.2 Cell level At the cell level, SingleCellMQC performs UMAP analysis on the original single-cell data to visualize batch-related variability. This approach is adaptable to both single-omics and multi-omics datasets. Additionally, SingleCellMQC also integrates the harmony method for batch correction. Users can compare the data before and after correction through UMAP visualizations. Moreover, SingleCellMQC calculates the percentage of variance explained by different variables for both RNA and surface protein features in the original single-cell data at the cell level. This method enables users to identify specific batch covariates that impact feature expression. The RunPipeline() function must be used to flow through the data to obtain the results of the clustering prior to the assessment of the batch effect. 6.2.1 RNA UMAP # RNA umap pbmc &lt;- RunPipeline(pbmc, preprocess=&quot;rna.umap&quot;) ## UMAP plot PlotReducedDim(pbmc , group.by = &quot;rna_cluster&quot;, reduction = &quot;rna.umap&quot;, split.by = &quot;orig.ident&quot;) 6.2.2 ADT UMAP # ADT umap pbmc &lt;- RunPipeline(pbmc, preprocess=&quot;adt.umap&quot;) ## UMAP plot PlotReducedDim(pbmc , group.by = &quot;adt_cluster&quot;, reduction = &quot;adt.umap&quot;, split.by = &quot;orig.ident&quot;) 6.2.3 RNA+ADT UMAP For CITE-seq data, CITE-seq data was integrated using Weighted Nearest Neighbor (WNN) analysis in the Seurat package. # WNN umap pbmc &lt;- RunPipeline(pbmc, preprocess=&quot;wnn.umap&quot;) ## UMAP plot PlotReducedDim(pbmc , group.by = &quot;wnn_clusters&quot;, reduction = &quot;wnn.umap&quot;, split.by = &quot;orig.ident&quot;) 6.2.4 harmony UMAP # WNN harmony umap pbmc &lt;- RunPipeline(pbmc, preprocess=&quot;wnn.umap.har&quot;) ## UMAP plot PlotReducedDim(pbmc , group.by = &quot;wnn_har_clusters&quot;, reduction = &quot;wnn.umap.har&quot;, split.by = &quot;orig.ident&quot;) 6.3 Feature level At the feature level, SingleCellMQC calculates the percentage of variance (R²) explained by different variables for both RNA and surface protein features. These analyses are performed at single-cell and pseudobulk levels, enabling users to quantify the contribution of batch-specific covariates to feature expression variation. For each feature, the proportion of variance explained (R²) by categorical variables (one-way ANOVA) or continuous covariates (linear regression). 6.3.1 Calculating per-feature variance explained by variables at cell level # Specify &#39;variables&#39; to see the effect of the variable of interest on gene expression out &lt;- RunVarExplainedPerFeature(pbmc, variables =c(&quot;percent.mt&quot;, &quot;nCount_RNA&quot;,&quot;Batch_EXP&quot;), type = &quot;cell&quot;, assay = &quot;RNA&quot;) # Interactive table (top 10) PlotVEPerFeature(out, return.type = &quot;interactive_table&quot;, ntop = 10, csv.name=&quot;cell_VE&quot;) Download as CSV Variance Explained per Feature (top 10) # Density plot PlotVEPerFeature(out, plot.type=&quot;density&quot;) 6.3.2 Calculating per-feature variance explained by variables at sample level # Specify &#39;variables&#39; to see the effect of the variable of interest on gene expression out &lt;- RunVarExplainedPerFeature(pbmc, variables =c(&quot;percent.mt&quot;, &quot;nCount_RNA&quot;,&quot;Batch_EXP&quot;), type = &quot;pseudobulk&quot;, assay = &quot;RNA&quot;) ## Warning in FUN(X[[i]], ...): Variable &#39;Batch_EXP&#39; has a unique value for every observation (R2=100% is trivial and uninformative). Skipping. # Interactive table (top 10) PlotVEPerFeature(out, return.type = &quot;interactive_table&quot;, ntop = 10, csv.name=&quot;sample_VE&quot;) Download as CSV Variance Explained per Feature (top 10) # Density plot PlotVEPerFeature(out, plot.type=&quot;density&quot;) "],["qc-html-report.html", "7 QC HTML report", " 7 QC HTML report Compiled: 2025-05-08 Written by Daihan Ji If you have already performed preprocessing, you can directly run the RunReport function to generate a QC web report. If not, you can run RunPreprocess to complete some basic workflows. Function Descriptions: RunPreprocess and RunReport: 1. RunPreprocess Function RunPreprocess is a function for data preprocessing and includes the following main features: Calculate Quality Metrics: Adds quality metrics (e.g., number of genes, mitochondrial percentage) to the metadata. Cell Type Annotation: Runs cell type annotation using the RunScType function. Doublet Detection: Detects doublets using specified methods (e.g., scDblFinder). Low-Quality Cell Detection: Filters low-quality cells using specified methods (e.g., MAD). Dimensionality Reduction: Runs a preprocessing pipeline (e.g., UMAP) for visualization and downstream analysis. 2. RunReport Function RunReport allows you to freely choose the sections of the report you want to generate. The available sections are: Sample QC Module section.sample: Sections to include in the Sample QC module. Default is c(1:3). 1: Run Sample QC: Sample quality assessment. 2: Run Sample QC: Outlier sample detection by cell type. 3: Run Sample QC: Sample identity verification. Cell QC Module section.cell: Sections to include in the Cell QC module. Default is c(1:2). 1: Run Cell QC: Low-quality cell information. 2: Run Cell QC: Doublet information. Feature QC Module section.feature: Sections to include in the Feature QC module. Default is 1. 1: Run Feature QC: Feature quality assessment. Batch QC Module section.batch: Sections to include in the Batch QC module. Default is 1:3. 1: Run Batch QC: Sample level. 2: Run Batch QC: Cell level. 3: Run Batch QC: Feature level. Load data library(SingleCellMQC) library(Seurat) library(BPCells) #Load a pre-existing Seurat object or processed raw data using SingleCellMQC. pbmc &lt;- readRDS(&quot;/data/pbmc.rds&quot;) Run Preprocessing Pipeline for Single-Cell Data (If no prior preprocessing has been performed) pbmc &lt;- RunPreprocess(pbmc, sample.by = &quot;orig.ident&quot;) Generate QC HTML Report RunReport( object=pbmc, tissue = &quot;blood&quot;, # tissue for PCT outlier sample detection. RNA.batch.by = c(&quot;orig.ident&quot;, &quot;Batch_EXP&quot;, &quot;Time_point&quot;), #Column name(s) in the metadata indicating RNA batch information (categorical variable) or other categorical variables for PCA or UMAP plot. Default is &quot;orig.ident&quot;. Only for: section.batch (1, 2). RNA.batch.covariate = c(&quot;nFeature_RNA&quot;, &quot;percent.mt&quot;, &quot;Batch_EXP&quot;, &quot;Time_point&quot;) #Covariates (can be categorical or continuous) for RNA SVD and ⁠Variance Explained⁠ analysis. Default is c(&quot;orig.ident&quot;, &quot;percent.mt&quot;, &quot;nFeature_RNA&quot;, &quot;nCount_RNA&quot;).Only for: section.batch (1, 3). ) "],["tips.html", "8 Tips 8.1 Progress updates 8.2 Future parallel", " 8 Tips Compiled: 2025-05-08 Written by Jiaying Zeng and Daihan Ji Here are some helpful tips for you to use SingleCellMQC more smoothly. 8.1 Progress updates Turning on the global progress update report feature before your analysis is suggested, so that you could keep better track of the whole QC progress. library(progressr) handlers(global = TRUE) 8.2 Future parallel Future parallel global memory setting When you initiate the work by future parallel, the default global memory limit is 500MB, which is often insufficient, so it’s recommended to set it to 1GB or higher. For example, you can set global memory limit to 1GB (1024 MB * 1024 KB/MB * 1024 B/KB). library(future) options(future.globals.maxSize = 1024 * 1024 * 1024) How to use parallelization library(future) # change the current plan to access parallelization plan(&quot;multiprocess&quot;, workers = 4) # task example: e.g. scDblFinder doublet detction pbmc&lt;- RunDbt_scDblFinder(pbmc, split.by = &quot;orig.ident&quot;, add.Seurat=T, do.topscore=T) # change the the current plan to sequential plan(&quot;sequential&quot;) Functions supporting Read data (v0.6.0+): Read10XData, Read10XH5Data Doublet detection (v0.6.0+): RunDbt_hybrid, RunDbt_bcds, RunDbt_cxds, RunDbt_scDblFinder, RunDbt_DoubletFinder, RunDbt_ADT "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
